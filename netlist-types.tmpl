// This file is part of edif2qasm.  It defines various data types needed to
// represent a netlist.

package main

// A Cell represents a type of logic cell.
type Cell interface {
	CreateInput(name EdifSymbol)  // Create a new input port.
	CreateOutput(name EdifSymbol) // Create a new output port.
	MakeInstance() Instance       // Return an instance of this cell type.
}

// An Instance represents an instance of a type of logic cell.
type Instance interface {
	TypeOfPort(p EdifSymbol) (PortType, bool)                      // Return a port's type given its name
	ConnectPort(oPort EdifSymbol, peer Instance, iPort EdifSymbol) // Connect our output port oPort to our peer's input port iPort.
	AliasPort(cPort EdifSymbol, peer Instance, pPort EdifSymbol)   // Alias two input ports or two output ports
	IncludeChild(name EdifSymbol, inst Instance)                   // Include an instance of another cell within our instance
	SetName(name EdifString)                                       // Assign a name to this instance
	Name() EdifString                                              // Return the name of this instance
	Qubo() Qubo                                                    // Return a QUBO corresponding to this instance
}

// A Net represents an {instance, port} pair (essentially the target of an
// output port)
type Net struct {
	Inst Instance
	Port EdifSymbol
}

// A PortType represents the type of a port.
type PortType int

// These are the values a PortType can take on.
const (
	NoSuchPort PortType = iota
	InputPort
	OutputPort
)

// BEGIN: Gnd boilerplate

// A GndCell represents a ground cell.
type GndCell struct {
	Inputs  []EdifSymbol // Named input ports
	Outputs []EdifSymbol // Named output ports
}

// CreateInput defines a new input port.
func (c *GndCell) CreateInput(name EdifSymbol) {
	c.Inputs = append(c.Inputs, name)
}

// CreateOutput defines a new output port.
func (c *GndCell) CreateOutput(name EdifSymbol) {
	c.Outputs = append(c.Outputs, name)
}

// MakeInstance creates a GndInst from a GndCell.
func (c *GndCell) MakeInstance() Instance {
	inst := GndInst{}
	inst.Inputs = make(map[EdifSymbol]Empty, len(c.Inputs))
	for _, p := range c.Inputs {
		inst.Inputs[p] = Empty{}
	}
	inst.Outputs = make(map[EdifSymbol][]Net, len(c.Outputs))
	for _, p := range c.Outputs {
		inst.Outputs[p] = make([]Net, 0)
	}
	inst.Aliases = make(map[EdifSymbol][]Net)
	inst.Children = make(map[EdifSymbol]Instance)
	return &inst
}

// A GndInst represents an instance of a GndCell.
type GndInst struct {
	InstName EdifString              // Name of this instance
	Aliases  map[EdifSymbol][]Net    // Aliases of our ports with other instances' ports
	Inputs   map[EdifSymbol]Empty    // Names of our input ports
	Outputs  map[EdifSymbol][]Net    // Connections from our outputs to other instances' inputs
	Children map[EdifSymbol]Instance // Instances of other cells that we rely upon
}

// Return a port's type given its name.
func (c *GndInst) TypeOfPort(p EdifSymbol) (PortType, bool) {
	if _, ok := c.Outputs[p]; ok {
		return OutputPort, true
	}
	if _, ok := c.Inputs[p]; ok {
		return InputPort, true
	}
	return NoSuchPort, false
}

// AliasPort connects our port cPort to our peer's port pPort.
func (c *GndInst) AliasPort(cPort EdifSymbol, peer Instance, pPort EdifSymbol) {
	// Append the new target to the alias list.
	if _, ok := c.Outputs[cPort]; ok {
		c.Aliases[cPort] = append(c.Aliases[cPort], Net{Inst: peer, Port: pPort})
		return
	}
	if _, ok := c.Inputs[cPort]; ok {
		c.Aliases[cPort] = append(c.Aliases[cPort], Net{Inst: peer, Port: pPort})
		return
	}

	// Abort if the port wasn't found at all.
	notify.Fatalf("Failed to find port %s to connect to port %s", cPort, pPort)
}

// ConnectPort connects our port oPort to our peer's port iPort.
func (c *GndInst) ConnectPort(oPort EdifSymbol, peer Instance, iPort EdifSymbol) {
	// Append the new target to the port's list of targets.
	if nets, ok := c.Outputs[oPort]; ok {
		c.Outputs[oPort] = append(nets, Net{Inst: peer, Port: iPort})
		return
	}

	// Abort if the port wasn't found at all.
	notify.Fatalf("Failed to find port %s to connect to port %s", oPort, iPort)
}

// Include an instance of another cell within our instance.
func (c *GndInst) IncludeChild(name EdifSymbol, inst Instance) {
	c.Children[name] = inst
}

// Assign a name to this ground instance.
func (c *GndInst) SetName(name EdifString) {
	c.InstName = name
}

// Return the name of this ground instance.
func (c *GndInst) Name() EdifString {
	return c.InstName
}

// Return the names of all input ports in this ground instance.
func (c *GndInst) InputNames() []EdifSymbol {
	names := make([]EdifSymbol, 0, len(c.Inputs))
	for nm := range c.Inputs {
		names = append(names, nm)
	}
	return names
}

// Return the names of all output ports in this ground instance.
func (c *GndInst) OutputNames() []EdifSymbol {
	names := make([]EdifSymbol, 0, len(c.Outputs))
	for nm := range c.Outputs {
		names = append(names, nm)
	}
	return names
}

// END: Gnd boilerplate

// MakeUnique makes a symbol name unique by prepending the instance name.
func MakeUnique(inst Instance, sym EdifSymbol) EdifSymbol {
	return EdifSymbol(inst.Name()) + "." + sym
}

// Qubo returns a QUBO that represents ground.
func (c *GndInst) Qubo() Qubo {
	outNames := c.OutputNames()
	if len(outNames) != 1 {
		notify.Fatalf("Gnd expects 1 output, not %d", len(outNames))
	}
	q0Name := MakeUnique(c, ".internal")
	q1Name := MakeUnique(c, outNames[0])
	qubo := Qubo{
		{
			Type:   Point,
			X:      q0Name,
			Weight: 0,
		},
		{
			Type:   Point,
			X:      q1Name,
			Weight: 1,
		},
		{
			Type:   Coupler,
			X:      q0Name,
			Y:      q1Name,
			Weight: 0,
		},
	}
	for _, next := range c.Outputs[outNames[0]] {
		nextName := MakeUnique(next.Inst, next.Port)
		qubo = append(qubo, QuboElt{
			Type: Chain,
			X:    q1Name,
			Y:    nextName,
		})
	}
	return qubo
}

// Qubo returns a QUBO that represents input power.
func (c *VccInst) Qubo() Qubo {
	outNames := c.OutputNames()
	if len(outNames) != 1 {
		notify.Fatalf("Vcc expects 1 output, not %d", len(outNames))
	}
	q0Name := MakeUnique(c, ".internal")
	q1Name := MakeUnique(c, outNames[0])
	qubo := Qubo{
		{
			Type:   Point,
			X:      q0Name,
			Weight: 0,
		},
		{
			Type:   Point,
			X:      q1Name,
			Weight: -1,
		},
		{
			Type:   Coupler,
			X:      q0Name,
			Y:      q1Name,
			Weight: 0,
		},
	}
	for _, next := range c.Outputs[outNames[0]] {
		nextName := MakeUnique(next.Inst, next.Port)
		qubo = append(qubo, QuboElt{
			Type: Chain,
			X:    q1Name,
			Y:    nextName,
		})
	}
	return qubo
}

// Qubo returns a QUBO that represents binary not.
func (c *NotInst) Qubo() Qubo {
	inNames := c.InputNames()
	if len(inNames) != 1 {
		notify.Fatalf("Not expects 1 input, not %d", len(inNames))
	}
	outNames := c.OutputNames()
	if len(outNames) != 1 {
		notify.Fatalf("Not expects 1 output, not %d", len(outNames))
	}
	q0Name := MakeUnique(c, inNames[0])
	q1Name := MakeUnique(c, outNames[0])
	qubo := Qubo{
		{
			Type:   Point,
			X:      q0Name,
			Weight: -1,
		},
		{
			Type:   Point,
			X:      q1Name,
			Weight: -1,
		},
		{
			Type:   Coupler,
			X:      q0Name,
			Y:      q1Name,
			Weight: 2,
		},
	}
	for _, next := range c.Outputs[outNames[0]] {
		nextName := MakeUnique(next.Inst, next.Port)
		qubo = append(qubo, QuboElt{
			Type: Chain,
			X:    q1Name,
			Y:    nextName,
		})
	}
	return qubo
}

// Qubo returns a QUBO that represents binary and.
func (c *AndInst) Qubo() Qubo {
	inNames := c.InputNames()
	if len(inNames) != 2 {
		notify.Fatalf("And expects 2 inputs, not %d", len(inNames))
	}
	outNames := c.OutputNames()
	if len(outNames) != 1 {
		notify.Fatalf("And expects 1 output, not %d", len(outNames))
	}
	q0Name := MakeUnique(c, inNames[0])
	q1Name := MakeUnique(c, inNames[1])
	q2Name := MakeUnique(c, outNames[0])
	qubo := Qubo{
		{
			Type:   Point,
			X:      q0Name,
			Weight: 0,
		},
		{
			Type:   Point,
			X:      q1Name,
			Weight: 0,
		},
		{
			Type:   Point,
			X:      q2Name,
			Weight: 3,
		},
		{
			Type:   Coupler,
			X:      q0Name,
			Y:      q1Name,
			Weight: 1,
		},
		{
			Type:   Coupler,
			X:      q0Name,
			Y:      q2Name,
			Weight: -2,
		},
		{
			Type:   Coupler,
			X:      q1Name,
			Y:      q2Name,
			Weight: -2,
		},
	}
	for _, next := range c.Outputs[outNames[0]] {
		nextName := MakeUnique(next.Inst, next.Port)
		qubo = append(qubo, QuboElt{
			Type: Chain,
			X:    q2Name,
			Y:    nextName,
		})
	}
	return qubo
}

// Qubo returns a QUBO that represents a multiplexer.
func (c *MuxInst) Qubo() Qubo {
	notify.Fatal("MuxInst.Qubo is not yet implemented")
	return nil
}

// Qubo returns a QUBO that represents a user-defined logic cell.
func (c *UserInst) Qubo() Qubo {
	// First process all of our (reachable) children.
	elts := make(Qubo, 0, len(c.Inputs)+len(c.Outputs))
	for _, child := range c.ReachableChildren() {
		elts = append(elts, child.Qubo()...)
	}

	// Alias our ports to those of our children.
	for nm, nets := range c.Aliases {
		for _, net := range nets {
			q0Name := MakeUnique(c, nm)
			q1Name := MakeUnique(net.Inst, net.Port)
			elts = append(elts, QuboElt{
				Type: Alias,
				X:    q0Name,
				Y:    q1Name,
			})
		}
	}

	// Chain output to input ports.
	for nm, nets := range c.Outputs {
		for _, net := range nets {
			q0Name := MakeUnique(c, nm)
			q1Name := MakeUnique(net.Inst, net.Port)
			elts = append(elts, QuboElt{
				Type: Chain,
				X:    q0Name,
				Y:    q1Name,
			})
		}
	}

	// Return the QUBO we constructed.
	return elts
}

// User-defined instances can contain children.  ReachableChildren returns a
// join of the UserInst's child instances and the instances reachable by its
// outputs.
func (c *UserInst) ReachableChildren() []Instance {
	// Start considering all children unreachable.
	isReachable := make(map[Instance]bool)
	for _, child := range c.Children {
		isReachable[child] = false
	}

	// Each output port that references a child marks the child as
	// reachable.
	for _, nets := range c.Outputs {
		for _, net := range nets {
			if reached, ok := isReachable[net.Inst]; ok && !reached {
				isReachable[net.Inst] = true
			}
		}
	}

	// Each aliased port that references a child marks the child as
	// reachable.
	for _, nets := range c.Aliases {
		for _, net := range nets {
			if reached, ok := isReachable[net.Inst]; ok && !reached {
				isReachable[net.Inst] = true
			}
		}
	}

	// Return a list of reachable children.
	reachable := make([]Instance, 0, len(isReachable))
	for c, r := range isReachable {
		if r {
			reachable = append(reachable, c)
		}
	}
	return reachable
}
